---
layout: post
title: "Deep Residual Shrinkage Network : une méthode d'IA pour les données fortement bruitées"
date: 2025-12-23
author: "Minghang Zhao, Harbin Institute of Technology"
tags: 
  - Deep Learning
  - Apprentissage profond
  - DRSN
  - Diagnostic de pannes
  - Traitement du signal
  - ResNet
  - Mécanisme d'attention
  - Seuillage doux
  - Débruitage
mathjax: true
description: "Le Deep Residual Shrinkage Network (DRSN) est une méthode d'apprentissage profond conçue pour les données fortement bruitées. Intégrant ResNet, des mécanismes d'attention et le seuillage doux, le DRSN excelle dans le diagnostic de pannes, le traitement du signal et la classification d'images grâce à un apprentissage de caractéristiques et un débruitage efficaces."
lang: fr
categories: fr
ref: drsn-2025
buttons:
  - type: hit
    text: HIT Homepage
    url: https://homepage.hit.edu.cn/zhaominghang?lang=zh
  - type: scholar
    text: Google Scholar
    url: https://scholar.google.com/citations?user=k82TzLwAAAAJ&hl=en
  - type: ieee
    text: IEEE Paper
    url: https://ieeexplore.ieee.org/document/8850096
  - type: github
    text: GitHub Code
    url: https://github.com/zhao62/Deep-Residual-Shrinkage-Networks
  - type: citation
    text: "Citations: 1400+"
    url: https://scholar.google.com/citations?user=k82TzLwAAAAJ&hl=en
---

**Le Deep Residual Shrinkage Network (DRSN) est une variante améliorée des réseaux résiduels profonds (ResNets). Il s'agit essentiellement d'une intégration des ResNets, des mécanismes d'attention et de la fonction de seuillage doux (soft thresholding).**

**Dans une certaine mesure, le principe de fonctionnement du DRSN peut s'interpréter ainsi : il utilise le mécanisme d'attention pour repérer les caractéristiques non pertinentes et les annuler via la fonction de seuillage doux ; inversement, il identifie et préserve les caractéristiques importantes. Ce processus renforce la capacité du réseau de neurones profond à extraire des informations utiles à partir de signaux bruités.**

## 1. Motivations de la recherche

**Premièrement, lors de la classification, les échantillons contiennent inévitablement du bruit**, tel que le bruit gaussien, le bruit rose ou le bruit de Laplace. Au sens large, les échantillons contiennent souvent des informations sans rapport avec la tâche en cours, ce qui peut aussi être considéré comme du bruit. Ces éléments parasites risquent de nuire à la performance de la classification. (Le seuillage doux est d'ailleurs une étape clé dans de nombreux algorithmes de débruitage de signal).

Prenons l'exemple d'une conversation au bord d'une route : la voix peut être mêlée à des bruits de klaxons ou de roulement. Lors de la reconnaissance vocale, ces sons parasites affectent inévitablement le résultat. Du point de vue du Deep Learning, les caractéristiques (features) correspondant à ces klaxons et bruits de roues devraient être éliminées au sein du réseau de neurones, afin d'éviter toute interférence.

**Deuxièmement, au sein d'un même jeu de données, la quantité de bruit varie souvent d'un échantillon à l'autre.** (Cela rejoint le principe du mécanisme d'attention : dans un jeu d'images, la position de l'objet cible varie, et l'attention permet de se focaliser sur la zone pertinente spécifique à chaque image).

Par exemple, pour l'entraînement d'un classifieur "chiens vs chats", considérons cinq images étiquetées "chien". La première peut contenir un chien et une souris, la deuxième un chien et une oie, la troisième un chien et un poulet, la quatrième un chien et un âne, et la cinquième un chien et un canard. Durant l'entraînement, le classifieur subit inévitablement les interférences de ces objets non pertinents (souris, oie, poulet, etc.), ce qui entraîne une baisse de la précision. Si nous pouvions identifier ces objets parasites et supprimer les caractéristiques qui leur correspondent, la précision du classifieur s'en trouverait améliorée.

## 2. Le seuillage doux (Soft Thresholding)

**Le seuillage doux est une étape fondamentale de nombreux algorithmes de débruitage. Il consiste à mettre à zéro les caractéristiques dont la valeur absolue est inférieure à un seuil donné, et à "contracter" vers zéro celles dont la valeur absolue est supérieure à ce seuil.** La formule est la suivante :

$$
y = \begin{cases} 
x - \tau & x > \tau \\ 
0 & -\tau \le x \le \tau \\ 
x + \tau & x < -\tau 
\end{cases}
$$

La dérivée de la sortie par rapport à l'entrée est :

$$
\frac{\partial y}{\partial x} = \begin{cases} 
1 & x > \tau \\ 
0 & -\tau \le x \le \tau \\ 
1 & x < -\tau 
\end{cases}
$$

Comme on peut le voir, la dérivée du seuillage doux vaut soit 1, soit 0. Cette propriété est identique à celle de la fonction d'activation ReLU. Par conséquent, le seuillage doux permet également de réduire les risques de **disparition et d'explosion du gradient** (gradient vanishing/exploding).

**Concernant le seuil, deux conditions doivent être respectées : premièrement, il doit être positif ; deuxièmement, il ne doit pas excéder la valeur maximale du signal d'entrée, sans quoi la sortie serait entièrement nulle.**

**Idéalement, une troisième condition devrait être remplie : chaque échantillon devrait posséder son propre seuil, adapté à son niveau de bruit spécifique.**

En effet, le contenu en bruit varie souvent d'un échantillon à l'autre. Il est fréquent, dans un même dataset, que l'échantillon A soit peu bruité tandis que l'échantillon B l'est fortement. Logiquement, lors du débruitage, l'échantillon A devrait se voir appliquer un seuil plus faible, et l'échantillon B un seuil plus élevé. Bien que dans les réseaux de neurones profonds, ces seuils perdent leur signification physique explicite, la logique fondamentale reste la même : chaque échantillon nécessite un seuil indépendant, déterminé par son propre contenu en bruit.

## 3. Le mécanisme d'attention

Ce mécanisme est assez intuitif dans le domaine de la vision par ordinateur. Le système visuel des animaux peut scanner rapidement une zone pour détecter une cible, puis focaliser son attention sur cet objet pour en extraire les détails, tout en inhibant les informations non pertinentes. (Pour plus de détails, se référer à la littérature sur les mécanismes d'attention).

Le **Squeeze-and-Excitation Network (SENet)** est une méthode de Deep Learning récente utilisant ce mécanisme. La contribution de chaque canal de caractéristiques (feature channel) à la tâche de classification varie souvent selon les échantillons. SENet utilise un petit sous-réseau pour générer un ensemble de poids, qui sont ensuite multipliés par les caractéristiques des canaux respectifs afin d'en ajuster l'importance. Ce processus s'apparente à l'application d'une attention d'intensité variable sur chaque canal.

<p align="center">
  <img src="/assets/img/DRSN/2025-11-25-DRSN-fr/SENET_fr_1.png" alt="Squeeze-and-Excitation Network" width="90%">
</p>

Ainsi, chaque échantillon possède son propre jeu de poids indépendants. Dans SENet, le cheminement pour obtenir ces poids est le suivant : "**Global Pooling** → **Couche dense** (Fully Connected) → ReLU → **Couche dense** → Sigmoïde".

<p align="center">
  <img src="/assets/img/DRSN/2025-11-25-DRSN-fr/SENET_fr_2.png" alt="Squeeze-and-Excitation Network" width="60%">
</p>

## 4. Le seuillage doux sous mécanisme d'attention profond

Le Deep Residual Shrinkage Network s'inspire de la structure du sous-réseau de SENet pour implémenter un seuillage doux dans un cadre d'attention profond. Grâce au sous-réseau (indiqué dans le cadre rouge), il est possible d'apprendre un ensemble de seuils pour appliquer un seuillage doux spécifique à chaque canal de caractéristiques.

<p align="center">
  <img src="/assets/img/DRSN/2025-11-25-DRSN-fr/DRSN_fr_1.png" alt="Deep Residual Shrinkage Network" width="75%">
</p>

Au sein de ce sous-réseau, on calcule d'abord la valeur absolue de toutes les caractéristiques de la carte d'entrée. On applique ensuite un **Global Average Pooling** pour obtenir une valeur unique, notée A. Parallèlement, ce résultat traverse un petit réseau dense (fully connected). La dernière couche de ce réseau utilise une fonction Sigmoïde pour normaliser la sortie entre 0 et 1, produisant un coefficient noté α. Le seuil final est alors représenté par α×A. Le seuil est donc le produit d'un nombre entre 0 et 1 et de la moyenne des valeurs absolues de la carte de caractéristiques. **Cette méthode garantit non seulement que le seuil est positif, mais aussi qu'il reste dans une plage de valeurs raisonnable.**

**De plus, le seuil varie d'un échantillon à l'autre. On peut donc y voir, dans une certaine mesure, un mécanisme d'attention spécialisé : il repère les caractéristiques non pertinentes pour la tâche, les transforme en valeurs proches de zéro via deux couches de convolution, puis les annule par seuillage doux ; à l'inverse, il identifie les caractéristiques pertinentes, les transforme en valeurs éloignées de zéro, et les préserve.**

Enfin, l'empilement d'un certain nombre de modules de base, accompagnés de couches de convolution, de **Batch Normalization**, de fonctions d'activation, de Global Average Pooling et d'une couche de sortie dense, constitue le Deep Residual Shrinkage Network complet.

<p align="center">
  <img src="/assets/img/DRSN/2025-11-25-DRSN-fr/DRSN_fr_2.png" alt="Deep Residual Shrinkage Network" width="55%">
</p>

## 5. Capacité de généralisation

Le Deep Residual Shrinkage Network est en fait une méthode d'apprentissage de caractéristiques générique. En effet, dans de nombreuses tâches d'apprentissage, les échantillons contiennent plus ou moins de bruit et d'informations non pertinentes. Ces éléments parasites peuvent affecter la performance du modèle. Par exemple :

En classification d'images, si une image contient de nombreux autres objets en arrière-plan, ceux-ci peuvent être considérés comme du "bruit". Le DRSN pourrait utiliser le mécanisme d'attention pour cibler ce "bruit" et le seuillage doux pour annuler les caractéristiques correspondantes, améliorant ainsi la précision de la classification.

En reconnaissance vocale, dans des environnements bruyants (bord de route, atelier d'usine), le DRSN pourrait améliorer la précision de la reconnaissance, ou du moins offrir une approche prometteuse pour y parvenir.

## 6. Impact académique

Cet article a été cité plus de 1400 fois sur Google Scholar.

Selon des statistiques non exhaustives, le Deep Residual Shrinkage Network a été utilisé directement ou amélioré dans plus de 1000 publications, couvrant des domaines variés tels que la mécanique, l'ingénierie électrique, la vision par ordinateur, le domaine médical, le traitement de la parole et du texte, le radar et la télédétection.

## 7. Informations sur l’article

<div style="background-color: #fff; border: 1px solid #e1e4e8; border-radius: 6px; padding: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); margin-bottom: 20px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;">
    
    <!-- 1. 论文标题 -->
    <div style="font-size: 18px; font-weight: 700; color: #0366d6; margin-bottom: 8px; line-height: 1.4;">
        <a href="https://ieeexplore.ieee.org/document/8850096" target="_blank" style="text-decoration: none; color: inherit; transition: color 0.2s;">
            Deep Residual Shrinkage Networks for Fault Diagnosis
        </a>
    </div>

    <!-- 2. 作者列表 -->
    <div style="font-size: 14px; color: #24292e; margin-bottom: 6px; line-height: 1.5;">
        <strong>Minghang Zhao</strong>, Shisheng Zhong, Xuyun Fu, Baoping Tang, Michael Pecht
    </div>

    <!-- 3. 期刊信息 -->
    <div style="font-size: 14px; color: #586069; font-style: italic; margin-bottom: 15px; line-height: 1.5;">
        IEEE Transactions on Industrial Informatics, vol. 16, no. 7, pp. 4681-4690, July 2020.
    </div>

    <!-- 4. 操作按钮行 (Mobile & Desktop Perfect) -->
    <div style="display: flex; gap: 8px; flex-wrap: wrap; align-items: center;">
        
        <!-- IEEE 官方链接 -->
        <a href="https://ieeexplore.ieee.org/document/8850096" target="_blank" style="text-decoration: none;">
            <div style="background: #00629B; color: white; padding: 5px 12px; border-radius: 4px; font-size: 12px; font-weight: 600; text-align: center; cursor: pointer; white-space: nowrap; line-height: normal; font-family: inherit;">
                IEEE Xplore
            </div>
        </a>

        <!-- PDF 下载 -->
        <a href="https://zhao62.github.io/assets/pdf/Zhao2020DRSN.pdf" target="_blank" style="text-decoration: none;">
            <div style="background: #cb2431; color: white; padding: 5px 12px; border-radius: 4px; font-size: 12px; font-weight: 600; text-align: center; cursor: pointer; white-space: nowrap; line-height: normal; font-family: inherit;">
                Download PDF
            </div>
        </a>

        <!-- 谷歌学术 -->
        <a href="https://scholar.google.com/citations?user=k82TzLwAAAAJ&hl=en" target="_blank" style="text-decoration: none;">
            <div style="background: #fff; color: #24292e; border: 1px solid #d1d5da; padding: 4px 11px; border-radius: 4px; font-size: 12px; font-weight: 600; text-align: center; cursor: pointer; white-space: nowrap; line-height: normal; font-family: inherit;">
                Google Scholar
            </div>
        </a>

        <!-- 复制纯文本按钮 -->
        <button id="btn-copy-cite-text-zhao2020" onclick="copyCitationText('citation-content-zhao2020', 'btn-copy-cite-text-zhao2020')" style="background: #f6f8fa; color: #24292e; border: 1px solid #d1d5da; padding: 4px 11px; border-radius: 4px; font-size: 12px; font-weight: 600; cursor: pointer; outline: none; font-family: inherit; line-height: normal;">
            Copy Citation
        </button>
    </div>

    <!-- 隐藏的纯文本源 -->
    <div id="citation-content-zhao2020" style="display: none;">M. Zhao, S. Zhong, X. Fu, B. Tang, and M. Pecht, "Deep Residual Shrinkage Networks for Fault Diagnosis," IEEE Transactions on Industrial Informatics, vol. 16, no. 7, pp. 4681-4690, 2020.</div>
</div>

<script>
function copyCitationText(contentId, btnId) {
    var content = document.getElementById(contentId).innerText;
    var btn = document.getElementById(btnId);

    function handleSuccess() {
        var originalText = btn.innerText;
        // 使用 textContent 兼容性更好
        btn.textContent = 'Copied! ✓';
        btn.style.color = '#22863a';
        btn.style.borderColor = '#22863a';
        setTimeout(function() {
            btn.textContent = 'Copy Citation';
            btn.style.color = '#24292e';
            btn.style.borderColor = '#d1d5da';
        }, 2000);
    }

    function handleError(err) {
        console.error('Copy failed', err);
        // 如果失败，不做任何操作，或者可以 alert
    }

    // 优先使用现代 Clipboard API
    if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(content).then(handleSuccess).catch(function() {
            fallbackCopyText(content);
        });
    } else {
        fallbackCopyText(content);
    }

    // 终极兼容：使用 execCommand
    function fallbackCopyText(text) {
        try {
            var textArea = document.createElement("textarea");
            textArea.value = text;
            
            // 关键优化：防止手机端弹出键盘
            textArea.setAttribute('readonly', '');
            textArea.style.position = "fixed";
            textArea.style.left = "-9999px";
            textArea.style.top = "0";
            
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            // 针对 iOS 的特殊处理
            var range = document.createRange();
            range.selectNodeContents(textArea);
            var selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            textArea.setSelectionRange(0, 999999);

            var successful = document.execCommand('copy');
            document.body.removeChild(textArea);
            
            if (successful) handleSuccess();
            else handleError('execCommand fail');
        } catch (err) {
            handleError(err);
        }
    }
}
</script>

## 8. BibTeX

<!-- 终极兼容版 BibTeX 块 -->
<div class="bibtex-container" style="border: 1px solid #e1e4e8; border-radius: 6px; background-color: #f6f8fa; margin-bottom: 16px; max-width: 100%;">
    
    <!-- 顶部工具栏 -->
    <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; border-bottom: 1px solid #e1e4e8; background-color: #ffffff; border-radius: 6px 6px 0 0;">
        <span style="font-size: 13px; font-weight: 600; color: #586069; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;">
            BibTeX
        </span>
        <button id="copy-btn-zhao2020" onclick="copyBibtexStable('bibtex-content-zhao2020', 'copy-btn-zhao2020')" style="border: 1px solid #d1d5da; background-color: #fff; color: #24292e; border-radius: 4px; padding: 4px 10px; font-size: 12px; cursor: pointer; font-weight: 600; line-height: 20px; transition: all 0.2s ease; outline: none;">
            Copy
        </button>
    </div>

    <!-- 代码区域 -->
    <div style="overflow-x: auto; padding: 15px;">
<!-- 注意：这里的第一行已经改成了 @article{Zhao2020DRSN, -->
<pre id="bibtex-content-zhao2020" style="margin: 0; font-family: SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace; font-size: 13px; line-height: 1.45; color: #24292e; white-space: pre;">@article{Zhao2020DRSN,
  author    = {Minghang Zhao and Shisheng Zhong and Xuyun Fu and Baoping Tang and Michael Pecht},
  title     = {Deep Residual Shrinkage Networks for Fault Diagnosis},
  journal   = {IEEE Transactions on Industrial Informatics},
  year      = {2020},
  volume    = {16},
  number    = {7},
  pages     = {4681-4690},
  doi       = {10.1109/TII.2019.2943898}
}</pre>
    </div>
</div>

<script>
/**
 * 高兼容性复制函数
 */
function copyBibtexStable(contentId, btnId) {
    var content = document.getElementById(contentId).innerText;
    var btn = document.getElementById(btnId);

    function handleSuccess() {
        btn.innerText = 'Copied! ✓';
        btn.style.color = '#22863a';
        btn.style.borderColor = '#22863a';
        setTimeout(function() {
            btn.innerText = 'Copy';
            btn.style.color = '#24292e';
            btn.style.borderColor = '#d1d5da';
        }, 2000);
    }

    function handleError(err) {
        console.error('Copy failed:', err);
        alert('Press Ctrl+C to copy');
    }

    if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(content).then(handleSuccess).catch(function() {
            fallbackCopy(content);
        });
    } else {
        fallbackCopy(content);
    }

    function fallbackCopy(text) {
        try {
            var textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed";
            textArea.style.left = "-9999px";
            textArea.style.top = "0";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            var successful = document.execCommand('copy');
            document.body.removeChild(textArea);
            if (successful) handleSuccess();
            else handleError('execCommand returned false');
        } catch (err) {
            handleError(err);
        }
    }
}
</script>
