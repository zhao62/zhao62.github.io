---
layout: post
title: "Deep Residual Shrinkage Network: Un metodo di Intelligenza Artificiale per dati altamente rumorosi"
date: 2025-12-23
author: "Minghang Zhao, Harbin Institute of Technology"
tags: [Deep Learning, AI]
mathjax: true
description: "La Deep Residual Shrinkage Network (DRSN) è una variante migliorata della Deep Residual Network (ResNet). In sostanza, rappresenta un'integrazione tra le ResNet, i meccanismi di attenzione e le funzioni di Soft Thresholding."
lang: it
categories: it
ref: drsn-2025
buttons:
  - type: hit
    text: HIT Homepage
    url: https://homepage.hit.edu.cn/zhaominghang?lang=zh
  - type: scholar
    text: Google Scholar
    url: https://scholar.google.com/citations?user=k82TzLwAAAAJ&hl=en
  - type: ieee
    text: IEEE Paper
    url: https://ieeexplore.ieee.org/document/8850096
  - type: github
    text: GitHub Code
    url: https://github.com/zhao62/Deep-Residual-Shrinkage-Networks
  - type: citation
    text: "Citations: 1400+"
    url: https://scholar.google.com/citations?user=k82TzLwAAAAJ&hl=en
---

**La Deep Residual Shrinkage Network (DRSN) è una variante migliorata della Deep Residual Network (ResNet). In sostanza, rappresenta un'integrazione tra le ResNet, i meccanismi di attenzione e le funzioni di Soft Thresholding.**

**In una certa misura, il principio di funzionamento della Deep Residual Shrinkage Network può essere interpretato così: attraverso il meccanismo di attenzione, la rete individua le feature non importanti e le azzera tramite la funzione di Soft Thresholding; analogamente, individua le feature importanti e le preserva. Questo processo potenzia la capacità della rete neurale profonda di estrarre feature utili da segnali affetti da rumore.**

## 1. Motivazione della Ricerca
**In primo luogo, nei compiti di classificazione, è inevitabile che i campioni contengano del rumore, come il rumore Gaussiano, il rumore rosa, il rumore Laplaciano, ecc.** In senso più ampio, i campioni contengono spesso informazioni non pertinenti al task di classificazione corrente; anche queste possono essere considerate "rumore" e possono impattare negativamente sulle performance di classificazione. (Il Soft Thresholding è un passaggio chiave in molti algoritmi di *signal denoising*).

Ad esempio, durante una conversazione a bordo strada, la voce potrebbe mescolarsi con il suono dei clacson o con il rumore di rotolamento degli pneumatici. Eseguendo il riconoscimento vocale su questi segnali, l'efficacia sarà inevitabilmente compromessa da questi suoni di sottofondo. Nella prospettiva del Deep Learning, le feature corrispondenti a clacson e rumori stradali dovrebbero essere eliminate all'interno della rete neurale, per evitare che influenzino il risultato del riconoscimento.

**In secondo luogo, anche all'interno dello stesso dataset, la quantità di rumore varia spesso da campione a campione.** (Questo concetto è affine al meccanismo di attenzione: prendendo come esempio un dataset di immagini, la posizione dell'oggetto target può variare; il meccanismo di attenzione è in grado di focalizzarsi sulla posizione specifica del target in ogni immagine).

Per esempio, addestrando un classificatore cane/gatto con 5 immagini etichettate come "cane": la prima potrebbe contenere un cane e un topo, la seconda un cane e un'oca, la terza un cane e una gallina, la quarta un cane e un asino, la quinta un cane e un'anatra. Durante il training, il modello subirebbe l'interferenza di oggetti irrilevanti (topi, oche, ecc.), causando un calo dell'accuratezza. Se fossimo in grado di individuare questi elementi irrilevanti ed eliminare le feature corrispondenti, potremmo migliorare l'accuratezza del classificatore.

## 2. Soft Thresholding
**Il Soft Thresholding è il passaggio centrale di molti algoritmi di riduzione del rumore. Esso elimina le feature il cui valore assoluto è inferiore a una certa soglia e "contrae" verso lo zero quelle il cui valore assoluto è superiore.** Questa operazione può essere realizzata attraverso la seguente formula:

$$
y = \begin{cases} 
x - \tau & x > \tau \\ 
0 & -\tau \le x \le \tau \\ 
x + \tau & x < -\tau 
\end{cases}
$$

La derivata dell'uscita del Soft Thresholding rispetto all'ingresso è:

$$
\frac{\partial y}{\partial x} = \begin{cases} 
1 & x > \tau \\ 
0 & -\tau \le x \le \tau \\ 
1 & x < -\tau 
\end{cases}
$$

Come si nota, la derivata è 1 oppure 0. Questa proprietà è identica a quella della funzione di attivazione ReLU. Di conseguenza, il Soft Thresholding riduce anche il rischio di *gradient vanishing* (scomparsa del gradiente) e *gradient exploding* (esplosione del gradiente) negli algoritmi di deep learning.

**Nella funzione di Soft Thresholding, l'impostazione della soglia deve soddisfare due condizioni: primo, la soglia deve essere positiva; secondo, non può superare il valore massimo del segnale in ingresso, altrimenti l'uscita sarebbe interamente zero.**

**Inoltre, è preferibile che la soglia soddisfi una terza condizione: ogni campione dovrebbe avere una propria soglia indipendente, basata sul proprio contenuto di rumore.**

Questo perché il livello di rumore varia tra i campioni. Spesso, nello stesso dataset, il campione A contiene poco rumore, mentre il campione B ne contiene molto. Pertanto, applicando il Soft Thresholding, il campione A dovrebbe adottare una soglia più bassa, e il campione B una più alta. Nelle reti neurali profonde, sebbene feature e soglie perdano un significato fisico esplicito, la logica di base rimane valida: ogni campione necessita di una soglia adattiva al proprio livello di rumore.

## 3. Meccanismo di Attenzione
Il meccanismo di attenzione è un concetto intuitivo nella Computer Vision. Il sistema visivo animale scansiona rapidamente un'area, individua il target e concentra l'attenzione su di esso per estrarre dettagli, sopprimendo le informazioni irrilevanti. Per approfondimenti, si rimanda alla letteratura specifica.

La Squeeze-and-Excitation Network (SENet) è un metodo di deep learning recente basato sull'attenzione. Il contributo dei vari canali delle feature (*feature channels*) alla classificazione varia tra i campioni. La SENet usa una piccola sottorete per ottenere un set di pesi, che vengono moltiplicati per le feature dei rispettivi canali per regolarne l'ampiezza. Questo processo equivale ad applicare diversi livelli di "attenzione" ai canali.

<p align="center">
  <img src="/assets/img/DRSN/2025-11-25-DRSN-it/SENET_it_1.png" alt="Squeeze-and-Excitation Network" width="90%">
</p>

In questo modo, ogni campione ha il proprio set indipendente di pesi. Nella SENet, il percorso per ottenere i pesi è: "Global Pooling → Fully Connected Layer → ReLU → Fully Connected Layer → Sigmoid".

<p align="center">
  <img src="/assets/img/DRSN/2025-11-25-DRSN-it/SENET_it_2.png" alt="Squeeze-and-Excitation Network" width="60%">
</p>

## 4. Soft Thresholding basato sul Meccanismo di Attenzione
La Deep Residual Shrinkage Network adotta la struttura della sottorete SENet per realizzare un Soft Thresholding guidato da un meccanismo di attenzione. Attraverso la sottorete (nel riquadro rosso), la rete apprende un set di soglie per applicare il Soft Thresholding ai vari canali delle feature.

<p align="center">
  <img src="/assets/img/DRSN/2025-11-25-DRSN-it/DRSN_it_1.png" alt="Deep Residual Shrinkage Network (DRSN)" width="75%">
</p>

In questa sottorete, si calcola prima il valore assoluto di tutte le feature nella feature map di input. Successivamente, tramite *Global Average Pooling*, si ottiene una feature scalare, indicata come A. In parallelo, la feature map post-pooling entra in una piccola rete *Fully Connected*. L'ultimo strato di questa rete usa una Sigmoide per normalizzare l'uscita tra 0 e 1, ottenendo un coefficiente α. La soglia finale è α×A. Quindi, la soglia è un numero tra 0 e 1 moltiplicato per la media dei valori assoluti della feature map. **Questo metodo garantisce che la soglia sia positiva e non eccessivamente grande.**

**Inoltre, campioni diversi avranno soglie diverse. Questo può essere inteso come un meccanismo di attenzione specializzato: la rete individua le feature irrilevanti, le trasforma in valori vicini allo 0 tramite strati convoluzionali e le azzera definitivamente con il Soft Thresholding; viceversa, individua le feature rilevanti e le preserva.**

Infine, impilando questi moduli base insieme a strati convoluzionali, *Batch Normalization*, funzioni di attivazione, *Global Average Pooling* e strati di output *Fully Connected*, si ottiene la Deep Residual Shrinkage Network completa.

<p align="center">
  <img src="/assets/img/DRSN/2025-11-25-DRSN-it/DRSN_it_2.png" alt="Deep Residual Shrinkage Network (DRSN)" width="55%">
</p>

## 5. Capacità di Generalizzazione
La Deep Residual Shrinkage Network è, di fatto, un metodo di *feature learning* universale. In molti task, i campioni contengono rumore o informazioni non pertinenti che influenzano l'apprendimento. Ad esempio:

Nella classificazione di immagini, se un'immagine contiene molti oggetti estranei, questi agiscono da "rumore"; la DRSN può sfruttare il meccanismo di attenzione per rilevare questo "rumore" e, tramite Soft Thresholding, azzerare le feature corrispondenti, migliorando l'accuratezza.

Nel riconoscimento vocale in ambienti rumorosi (strade, fabbriche), la DRSN può migliorare l'accuratezza o fornire una metodologia valida per ottenerla.

## 6. Impatto Accademico

Le citazioni su Google Scholar hanno superato quota 1400.

Secondo stime prudenti, la Deep Residual Shrinkage Network è stata applicata (direttamente o con miglioramenti) in oltre 1000 pubblicazioni in settori quali ingegneria meccanica, ingegneria elettrica, computer vision, medicina, elaborazione vocale e del testo, radar e telerilevamento.

## 7. Informazioni sull’articolo

<div style="background-color: #fff; border: 1px solid #e1e4e8; border-radius: 6px; padding: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); margin-bottom: 20px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;">
    
    <!-- 1. 论文标题 -->
    <div style="font-size: 18px; font-weight: 700; color: #0366d6; margin-bottom: 8px; line-height: 1.4;">
        <a href="https://ieeexplore.ieee.org/document/8850096" target="_blank" style="text-decoration: none; color: inherit; transition: color 0.2s;">
            Deep Residual Shrinkage Networks for Fault Diagnosis
        </a>
    </div>

    <!-- 2. 作者列表 -->
    <div style="font-size: 14px; color: #24292e; margin-bottom: 6px; line-height: 1.5;">
        <strong>Minghang Zhao</strong>, Shisheng Zhong, Xuyun Fu, Baoping Tang, Michael Pecht
    </div>

    <!-- 3. 期刊信息 -->
    <div style="font-size: 14px; color: #586069; font-style: italic; margin-bottom: 15px; line-height: 1.5;">
        IEEE Transactions on Industrial Informatics, vol. 16, no. 7, pp. 4681-4690, July 2020.
    </div>

    <!-- 4. 操作按钮行 (Mobile & Desktop Perfect) -->
    <div style="display: flex; gap: 8px; flex-wrap: wrap; align-items: center;">
        
        <!-- IEEE 官方链接 -->
        <a href="https://ieeexplore.ieee.org/document/8850096" target="_blank" style="text-decoration: none;">
            <div style="background: #00629B; color: white; padding: 5px 12px; border-radius: 4px; font-size: 12px; font-weight: 600; text-align: center; cursor: pointer; white-space: nowrap; line-height: normal; font-family: inherit;">
                IEEE Xplore
            </div>
        </a>

        <!-- PDF 下载 -->
        <a href="https://zhao62.github.io/assets/pdf/Zhao2020DRSN.pdf" target="_blank" style="text-decoration: none;">
            <div style="background: #cb2431; color: white; padding: 5px 12px; border-radius: 4px; font-size: 12px; font-weight: 600; text-align: center; cursor: pointer; white-space: nowrap; line-height: normal; font-family: inherit;">
                Download PDF
            </div>
        </a>

        <!-- 谷歌学术 -->
        <a href="https://scholar.google.com/citations?user=k82TzLwAAAAJ&hl=en" target="_blank" style="text-decoration: none;">
            <div style="background: #fff; color: #24292e; border: 1px solid #d1d5da; padding: 4px 11px; border-radius: 4px; font-size: 12px; font-weight: 600; text-align: center; cursor: pointer; white-space: nowrap; line-height: normal; font-family: inherit;">
                Google Scholar
            </div>
        </a>

        <!-- 复制纯文本按钮 -->
        <button id="btn-copy-cite-text-zhao2020" onclick="copyCitationText('citation-content-zhao2020', 'btn-copy-cite-text-zhao2020')" style="background: #f6f8fa; color: #24292e; border: 1px solid #d1d5da; padding: 4px 11px; border-radius: 4px; font-size: 12px; font-weight: 600; cursor: pointer; outline: none; font-family: inherit; line-height: normal;">
            Copy Citation
        </button>
    </div>

    <!-- 隐藏的纯文本源 -->
    <div id="citation-content-zhao2020" style="display: none;">M. Zhao, S. Zhong, X. Fu, B. Tang, and M. Pecht, "Deep Residual Shrinkage Networks for Fault Diagnosis," IEEE Transactions on Industrial Informatics, vol. 16, no. 7, pp. 4681-4690, 2020.</div>
</div>

<script>
function copyCitationText(contentId, btnId) {
    var content = document.getElementById(contentId).innerText;
    var btn = document.getElementById(btnId);

    function handleSuccess() {
        var originalText = btn.innerText;
        // 使用 textContent 兼容性更好
        btn.textContent = 'Copied! ✓';
        btn.style.color = '#22863a';
        btn.style.borderColor = '#22863a';
        setTimeout(function() {
            btn.textContent = 'Copy Citation';
            btn.style.color = '#24292e';
            btn.style.borderColor = '#d1d5da';
        }, 2000);
    }

    function handleError(err) {
        console.error('Copy failed', err);
        // 如果失败，不做任何操作，或者可以 alert
    }

    // 优先使用现代 Clipboard API
    if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(content).then(handleSuccess).catch(function() {
            fallbackCopyText(content);
        });
    } else {
        fallbackCopyText(content);
    }

    // 终极兼容：使用 execCommand
    function fallbackCopyText(text) {
        try {
            var textArea = document.createElement("textarea");
            textArea.value = text;
            
            // 关键优化：防止手机端弹出键盘
            textArea.setAttribute('readonly', '');
            textArea.style.position = "fixed";
            textArea.style.left = "-9999px";
            textArea.style.top = "0";
            
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            // 针对 iOS 的特殊处理
            var range = document.createRange();
            range.selectNodeContents(textArea);
            var selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            textArea.setSelectionRange(0, 999999);

            var successful = document.execCommand('copy');
            document.body.removeChild(textArea);
            
            if (successful) handleSuccess();
            else handleError('execCommand fail');
        } catch (err) {
            handleError(err);
        }
    }
}
</script>

## 8. BibTeX

<!-- 终极兼容版 BibTeX 块 -->
<div class="bibtex-container" style="border: 1px solid #e1e4e8; border-radius: 6px; background-color: #f6f8fa; margin-bottom: 16px; max-width: 100%;">
    
    <!-- 顶部工具栏 -->
    <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; border-bottom: 1px solid #e1e4e8; background-color: #ffffff; border-radius: 6px 6px 0 0;">
        <span style="font-size: 13px; font-weight: 600; color: #586069; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;">
            BibTeX
        </span>
        <button id="copy-btn-zhao2020" onclick="copyBibtexStable('bibtex-content-zhao2020', 'copy-btn-zhao2020')" style="border: 1px solid #d1d5da; background-color: #fff; color: #24292e; border-radius: 4px; padding: 4px 10px; font-size: 12px; cursor: pointer; font-weight: 600; line-height: 20px; transition: all 0.2s ease; outline: none;">
            Copy
        </button>
    </div>

    <!-- 代码区域 -->
    <div style="overflow-x: auto; padding: 15px;">
<!-- 注意：这里的第一行已经改成了 @article{Zhao2020DRSN, -->
<pre id="bibtex-content-zhao2020" style="margin: 0; font-family: SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace; font-size: 13px; line-height: 1.45; color: #24292e; white-space: pre;">@article{Zhao2020DRSN,
  author    = {Minghang Zhao and Shisheng Zhong and Xuyun Fu and Baoping Tang and Michael Pecht},
  title     = {Deep Residual Shrinkage Networks for Fault Diagnosis},
  journal   = {IEEE Transactions on Industrial Informatics},
  year      = {2020},
  volume    = {16},
  number    = {7},
  pages     = {4681-4690},
  doi       = {10.1109/TII.2019.2943898}
}</pre>
    </div>
</div>

<script>
/**
 * 高兼容性复制函数
 */
function copyBibtexStable(contentId, btnId) {
    var content = document.getElementById(contentId).innerText;
    var btn = document.getElementById(btnId);

    function handleSuccess() {
        btn.innerText = 'Copied! ✓';
        btn.style.color = '#22863a';
        btn.style.borderColor = '#22863a';
        setTimeout(function() {
            btn.innerText = 'Copy';
            btn.style.color = '#24292e';
            btn.style.borderColor = '#d1d5da';
        }, 2000);
    }

    function handleError(err) {
        console.error('Copy failed:', err);
        alert('Press Ctrl+C to copy');
    }

    if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(content).then(handleSuccess).catch(function() {
            fallbackCopy(content);
        });
    } else {
        fallbackCopy(content);
    }

    function fallbackCopy(text) {
        try {
            var textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed";
            textArea.style.left = "-9999px";
            textArea.style.top = "0";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            var successful = document.execCommand('copy');
            document.body.removeChild(textArea);
            if (successful) handleSuccess();
            else handleError('execCommand returned false');
        } catch (err) {
            handleError(err);
        }
    }
}
</script>
