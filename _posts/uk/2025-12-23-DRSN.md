---
layout: post
title: "Глибокі залишкові мережі зі стисненням (Deep Residual Shrinkage Network): Метод штучного інтелекту для даних із сильним шумом"
date: 2025-12-23
author: "Minghang Zhao, Harbin Institute of Technology"
tags: 
  - Глибоке навчання
  - Deep Learning
  - DRSN
  - Діагностика несправностей
  - Fault Diagnosis
  - Обробка сигналів
  - Signal Processing
  - ResNet
  - Механізм уваги
  - М'яка порогова обробка
  - Шумозаглушення
mathjax: true
description: "Deep Residual Shrinkage Network (DRSN) — це метод глибокого навчання, розроблений для даних із сильним шумом. Інтегруючи ResNet, механізми уваги та м'яку порогову обробку, DRSN демонструє високу ефективність у діагностиці несправностей, обробці сигналів та класифікації зображень, забезпечуючи ефективне навчання ознак і шумозаглушення."
lang: uk
categories: uk
ref: drsn-2025
buttons:
  - type: hit
    text: HIT Homepage
    url: https://homepage.hit.edu.cn/zhaominghang?lang=zh
  - type: scholar
    text: Google Scholar
    url: https://scholar.google.com/citations?user=k82TzLwAAAAJ&hl=en
  - type: ieee
    text: IEEE Paper
    url: https://ieeexplore.ieee.org/document/8850096
  - type: github
    text: GitHub Code
    url: https://github.com/zhao62/Deep-Residual-Shrinkage-Networks
  - type: citation
    text: "Citations: 1400+"
    url: https://scholar.google.com/citations?user=k82TzLwAAAAJ&hl=en
---

**Глибока залишкова мережа зі стисненням (Deep Residual Shrinkage Network, DRSN) — це покращена версія класичної глибокої залишкової мережі (ResNet). По суті, це інтеграція ResNet, механізмів уваги та функцій м'якої порогової обробки (soft thresholding).**

**Певною мірою принцип роботи DRSN можна зрозуміти так: за допомогою механізму уваги мережа виявляє неважливі ознаки та обнуляє їх через функцію м'якої порогової обробки; або ж, навпаки, виявляє важливі ознаки та зберігає їх. Цей процес значно посилює здатність глибокої нейронної мережі витягувати корисні ознаки (features) із сигналів, що містять шум.**

## 1. Мотивація дослідження
**По-перше, при класифікації зразків у них неминуче присутній певний шум, наприклад, гаусів шум, рожевий шум, лапласів шум тощо.** Більш узагальнено, зразки часто містять інформацію, не пов'язану з поточною задачею класифікації, яку також можна розглядати як шум. Цей шум може негативно вплинути на результати класифікації. (Варто зазначити, що м'яка порогова обробка є ключовим етапом у багатьох алгоритмах шумозаглушення сигналу).

Наприклад, під час розмови на узбіччі дороги аудіосигнал може змішуватися зі звуками автомобільних гудків та шумом коліс. Якщо виконувати розпізнавання мови на таких сигналах, результати неминуче постраждають від цих сторонніх звуків. З погляду глибокого навчання (Deep Learning), ознаки, що відповідають гудкам та шуму коліс, повинні бути видалені всередині глибокої нейронної мережі, щоб уникнути їхнього впливу на результат розпізнавання мови.

**По-друге, навіть у межах одного набору даних (dataset) кількість шуму в різних зразках часто відрізняється.** (Це перегукується з ідеєю механізмів уваги; якщо взяти як приклад набір зображень, то розташування цільового об'єкта може відрізнятися на різних картинках, і механізм уваги дозволяє фокусуватися саме на розташуванні об'єкта в кожному конкретному випадку).

Наприклад, при навчанні класифікатора "кішка/собака", розглянемо 5 зображень з міткою "собака". Перше зображення може містити собаку і мишу, друге — собаку і гусака, третє — собаку і курку, четверте — собаку і віслюка, а п'яте — собаку і качку. Під час навчання класифікатор неминуче піддаватиметься впливу нерелевантних об'єктів (мишей, гусей, курей, віслюків та качок), що призведе до зниження точності класифікації. Якщо ми зможемо виявити ці сторонні об'єкти та видалити відповідні їм ознаки, це дозволить підвищити точність класифікатора.

## 2. М'яка порогова обробка (Soft Thresholding)
**М'яка порогова обробка — це основний етап багатьох алгоритмів очищення сигналу від шуму. Вона видаляє ознаки, абсолютне значення яких менше певного порогу, і "стягує" (shrink) до нуля ті ознаки, абсолютне значення яких перевищує цей поріг.** Цей процес можна описати такою формулою:

$$
y = \begin{cases} 
x - \tau & x > \tau \\ 
0 & -\tau \le x \le \tau \\ 
x + \tau & x < -\tau 
\end{cases}
$$

Похідна вихідного значення м'якої порогової обробки по відношенню до вхідного виглядає так:

$$
\frac{\partial y}{\partial x} = \begin{cases} 
1 & x > \tau \\ 
0 & -\tau \le x \le \tau \\ 
1 & x < -\tau 
\end{cases}
$$

Як видно з формул, похідна м'якої порогової обробки дорівнює або 1, або 0. Ця властивість ідентична властивості функції активації ReLU. Тому використання м'якої порогової обробки також дозволяє знизити ризик виникнення проблем зникання градієнта (gradient vanishing) та вибуху градієнта (gradient exploding) в алгоритмах глибокого навчання.

**У функції м'якої порогової обробки налаштування порогу повинно відповідати двом умовам: по-перше, поріг має бути додатним числом; по-друге, поріг не може перевищувати максимальне значення вхідного сигналу, інакше вихід повністю складатиметься з нулів.**

**Крім того, бажано, щоб поріг відповідав третій умові: кожен зразок повинен мати свій власний незалежний поріг, що базується на рівні шуму в цьому конкретному зразку.**

Це пов'язано з тим, що вміст шуму в зразках часто різниться. Наприклад, у межах одного набору даних часто трапляється ситуація, коли зразок A містить менше шуму, а зразок B — більше. У такому випадку, при виконанні м'якої порогової обробки в алгоритмах шумозаглушення, для зразка A слід використовувати менший поріг, а для зразка B — більший. У глибоких нейронних мережах, хоча ці ознаки та пороги втрачають чіткий фізичний зміст, базова логіка залишається незмінною. Тобто, кожен зразок повинен мати власний адаптивний поріг.

## 3. Механізм уваги (Attention Mechanism)
Механізм уваги в галузі комп'ютерного зору зрозуміти досить легко. Зорова система тварин здатна швидко сканувати всю зону огляду, виявляти цільовий об'єкт і фокусувати на ньому увагу для отримання більшої кількості деталей, одночасно пригнічуючи нерелевантну інформацію. Детальніше про це можна дізнатися з літератури, присвяченої механізмам уваги.

Squeeze-and-Excitation Network (SENet) — це відносно новий метод глибокого навчання, що використовує механізми уваги. Вклад різних каналів ознак (feature channels) у виконання задачі класифікації часто варіюється від зразка до зразка. SENet використовує невелику підмережу для отримання набору ваг, а потім множить ці ваги на ознаки відповідних каналів, щоб скоригувати їх величину. Цей процес можна розглядати як застосування різного рівня "уваги" до різних каналів ознак.

<p align="center">
  <img src="/assets/img/DRSN/2025-11-30-DRSN-uk/SENET_uk_1.png" alt="Squeeze-and-Excitation Network" width="90%">
</p>

При такому підході кожен зразок отримує свій власний незалежний набір ваг. Іншими словами, для будь-яких двох зразків ваги будуть різними. У SENet шлях отримання ваг виглядає так: "Глобальний пулінг (Global Pooling) → Повнозв'язний шар (FC layer) → Функція ReLU → Повнозв'язний шар → Функція Sigmoid".

<p align="center">
  <img src="/assets/img/DRSN/2025-11-30-DRSN-uk/SENET_uk_2.png" alt="Squeeze-and-Excitation Network" width="60%">
</p>

## 4. М'яка порогова обробка з механізмом глибокої уваги
Мережа DRSN запозичує структуру вищезгаданої підмережі SENet для реалізації м'якої порогової обробки під керуванням механізму глибокої уваги. Через спеціальну підмережу (позначену червоною рамкою на схемах архітектури) можна навчитися генерувати набір порогів для застосування м'якої порогової обробки до кожного каналу ознак.

<p align="center">
  <img src="/assets/img/DRSN/2025-11-30-DRSN-uk/DRSN_uk_1.png" alt="Deep Residual Shrinkage Network" width="75%">
</p>

У цій підмережі спочатку обчислюються абсолютні значення всіх ознак вхідної карти ознак. Потім, через глобальний пулінг усреднення (global average pooling), отримується одна усереднена ознака, яку ми позначимо як A. Паралельно карта ознак після глобального пулінгу подається в невелику повнозв'язну мережу. Ця повнозв'язна мережа використовує функцію Sigmoid як останній шар, щоб нормалізувати вихідне значення в діапазоні від 0 до 1, отримуючи коефіцієнт, який ми позначимо як α. Остаточний поріг можна виразити як α × A. Таким чином, поріг — це число від 0 до 1, помножене на середнє значення абсолютних величин карти ознак. **Такий метод гарантує, що поріг буде не тільки додатним, але й не надто великим.**

**Більше того, різні зразки отримують різні пороги. Тому, певною мірою, це можна розглядати як спеціальний механізм уваги: мережа помічає ознаки, не пов'язані з поточним завданням, перетворює їх за допомогою згорткових шарів у значення, близькі до нуля, і через м'яку порогову обробку остаточно обнуляє їх. Або ж навпаки: помічає важливі ознаки, перетворює їх у значення, далекі від нуля, і зберігає їх.**

Зрештою, шляхом накладання (stacking) певної кількості базових блоків, а також шарів згортки, пакетної нормалізації (Batch Normalization), функцій активації, глобального пулінгу та повнозв'язних вихідних шарів, будується повна архітектура DRSN.

<p align="center">
  <img src="/assets/img/DRSN/2025-11-30-DRSN-uk/DRSN_uk_2.png" alt="Deep Residual Shrinkage Network" width="55%">
</p>

## 5. Універсальність
Фактично, DRSN — це універсальний метод навчання ознак (feature learning). Це пояснюється тим, що в багатьох задачах навчання ознак зразки тією чи іншою мірою містять шум та нерелевантну інформацію. Цей шум може впливати на ефективність навчання. Наприклад:

При класифікації зображень, якщо картинка містить багато сторонніх об'єктів, їх можна розглядати як "шум". DRSN може використовувати механізм уваги, щоб помітити цей "шум", а потім застосувати м'яку порогову обробку, щоб обнулити ознаки, що відповідають цьому "шуму", тим самим підвищуючи точність класифікації зображень.

У розпізнаванні мови, особливо в шумному середовищі (наприклад, розмова на вулиці або в заводському цеху), DRSN може підвищити точність розпізнавання або, як мінімум, запропонувати перспективний підхід для покращення результатів у таких умовах.

## 6. Вплив у науковій спільноті

Кількість цитувань цієї статті в Google Scholar перевищила 1400 разів.

За неповними статистичними даними, мережі DRSN були використані або вдосконалені в більш ніж 1000 наукових публікаціях у таких галузях, як механічна інженерія, енергетика, комп'ютерний зір, медицина, обробка мови, аналіз тексту, радіолокація, дистанційне зондування та багатьох інших.

## 7. Інформація про статтю

<div style="background-color: #fff; border: 1px solid #e1e4e8; border-radius: 6px; padding: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); margin-bottom: 20px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;">
    
    <!-- 1. 论文标题 -->
    <div style="font-size: 18px; font-weight: 700; color: #0366d6; margin-bottom: 8px; line-height: 1.4;">
        <a href="https://ieeexplore.ieee.org/document/8850096" target="_blank" style="text-decoration: none; color: inherit; transition: color 0.2s;">
            Deep Residual Shrinkage Networks for Fault Diagnosis
        </a>
    </div>

    <!-- 2. 作者列表 -->
    <div style="font-size: 14px; color: #24292e; margin-bottom: 6px; line-height: 1.5;">
        <strong>Minghang Zhao</strong>, Shisheng Zhong, Xuyun Fu, Baoping Tang, Michael Pecht
    </div>

    <!-- 3. 期刊信息 -->
    <div style="font-size: 14px; color: #586069; font-style: italic; margin-bottom: 15px; line-height: 1.5;">
        IEEE Transactions on Industrial Informatics, vol. 16, no. 7, pp. 4681-4690, July 2020.
    </div>

    <!-- 4. 操作按钮行 (Mobile & Desktop Perfect) -->
    <div style="display: flex; gap: 8px; flex-wrap: wrap; align-items: center;">
        
        <!-- IEEE 官方链接 -->
        <a href="https://ieeexplore.ieee.org/document/8850096" target="_blank" style="text-decoration: none;">
            <div style="background: #00629B; color: white; padding: 5px 12px; border-radius: 4px; font-size: 12px; font-weight: 600; text-align: center; cursor: pointer; white-space: nowrap; line-height: normal; font-family: inherit;">
                IEEE Xplore
            </div>
        </a>

        <!-- PDF 下载 -->
        <a href="https://zhao62.github.io/assets/pdf/Zhao2020DRSN.pdf" target="_blank" style="text-decoration: none;">
            <div style="background: #cb2431; color: white; padding: 5px 12px; border-radius: 4px; font-size: 12px; font-weight: 600; text-align: center; cursor: pointer; white-space: nowrap; line-height: normal; font-family: inherit;">
                Download PDF
            </div>
        </a>

        <!-- 谷歌学术 -->
        <a href="https://scholar.google.com/citations?user=k82TzLwAAAAJ&hl=en" target="_blank" style="text-decoration: none;">
            <div style="background: #fff; color: #24292e; border: 1px solid #d1d5da; padding: 4px 11px; border-radius: 4px; font-size: 12px; font-weight: 600; text-align: center; cursor: pointer; white-space: nowrap; line-height: normal; font-family: inherit;">
                Google Scholar
            </div>
        </a>

        <!-- 复制纯文本按钮 -->
        <button id="btn-copy-cite-text-zhao2020" onclick="copyCitationText('citation-content-zhao2020', 'btn-copy-cite-text-zhao2020')" style="background: #f6f8fa; color: #24292e; border: 1px solid #d1d5da; padding: 4px 11px; border-radius: 4px; font-size: 12px; font-weight: 600; cursor: pointer; outline: none; font-family: inherit; line-height: normal;">
            Copy Citation
        </button>
    </div>

    <!-- 隐藏的纯文本源 -->
    <div id="citation-content-zhao2020" style="display: none;">M. Zhao, S. Zhong, X. Fu, B. Tang, and M. Pecht, "Deep Residual Shrinkage Networks for Fault Diagnosis," IEEE Transactions on Industrial Informatics, vol. 16, no. 7, pp. 4681-4690, 2020.</div>
</div>

<script>
function copyCitationText(contentId, btnId) {
    var content = document.getElementById(contentId).innerText;
    var btn = document.getElementById(btnId);

    function handleSuccess() {
        var originalText = btn.innerText;
        // 使用 textContent 兼容性更好
        btn.textContent = 'Copied! ✓';
        btn.style.color = '#22863a';
        btn.style.borderColor = '#22863a';
        setTimeout(function() {
            btn.textContent = 'Copy Citation';
            btn.style.color = '#24292e';
            btn.style.borderColor = '#d1d5da';
        }, 2000);
    }

    function handleError(err) {
        console.error('Copy failed', err);
        // 如果失败，不做任何操作，或者可以 alert
    }

    // 优先使用现代 Clipboard API
    if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(content).then(handleSuccess).catch(function() {
            fallbackCopyText(content);
        });
    } else {
        fallbackCopyText(content);
    }

    // 终极兼容：使用 execCommand
    function fallbackCopyText(text) {
        try {
            var textArea = document.createElement("textarea");
            textArea.value = text;
            
            // 关键优化：防止手机端弹出键盘
            textArea.setAttribute('readonly', '');
            textArea.style.position = "fixed";
            textArea.style.left = "-9999px";
            textArea.style.top = "0";
            
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            // 针对 iOS 的特殊处理
            var range = document.createRange();
            range.selectNodeContents(textArea);
            var selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            textArea.setSelectionRange(0, 999999);

            var successful = document.execCommand('copy');
            document.body.removeChild(textArea);
            
            if (successful) handleSuccess();
            else handleError('execCommand fail');
        } catch (err) {
            handleError(err);
        }
    }
}
</script>

## 8. BibTeX

<!-- 终极兼容版 BibTeX 块 -->
<div class="bibtex-container" style="border: 1px solid #e1e4e8; border-radius: 6px; background-color: #f6f8fa; margin-bottom: 16px; max-width: 100%;">
    
    <!-- 顶部工具栏 -->
    <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; border-bottom: 1px solid #e1e4e8; background-color: #ffffff; border-radius: 6px 6px 0 0;">
        <span style="font-size: 13px; font-weight: 600; color: #586069; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;">
            BibTeX
        </span>
        <button id="copy-btn-zhao2020" onclick="copyBibtexStable('bibtex-content-zhao2020', 'copy-btn-zhao2020')" style="border: 1px solid #d1d5da; background-color: #fff; color: #24292e; border-radius: 4px; padding: 4px 10px; font-size: 12px; cursor: pointer; font-weight: 600; line-height: 20px; transition: all 0.2s ease; outline: none;">
            Copy
        </button>
    </div>

    <!-- 代码区域 -->
    <div style="overflow-x: auto; padding: 15px;">
<!-- 注意：这里的第一行已经改成了 @article{Zhao2020DRSN, -->
<pre id="bibtex-content-zhao2020" style="margin: 0; font-family: SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace; font-size: 13px; line-height: 1.45; color: #24292e; white-space: pre;">@article{Zhao2020DRSN,
  author    = {Minghang Zhao and Shisheng Zhong and Xuyun Fu and Baoping Tang and Michael Pecht},
  title     = {Deep Residual Shrinkage Networks for Fault Diagnosis},
  journal   = {IEEE Transactions on Industrial Informatics},
  year      = {2020},
  volume    = {16},
  number    = {7},
  pages     = {4681-4690},
  doi       = {10.1109/TII.2019.2943898}
}</pre>
    </div>
</div>

<script>
/**
 * 高兼容性复制函数
 */
function copyBibtexStable(contentId, btnId) {
    var content = document.getElementById(contentId).innerText;
    var btn = document.getElementById(btnId);

    function handleSuccess() {
        btn.innerText = 'Copied! ✓';
        btn.style.color = '#22863a';
        btn.style.borderColor = '#22863a';
        setTimeout(function() {
            btn.innerText = 'Copy';
            btn.style.color = '#24292e';
            btn.style.borderColor = '#d1d5da';
        }, 2000);
    }

    function handleError(err) {
        console.error('Copy failed:', err);
        alert('Press Ctrl+C to copy');
    }

    if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(content).then(handleSuccess).catch(function() {
            fallbackCopy(content);
        });
    } else {
        fallbackCopy(content);
    }

    function fallbackCopy(text) {
        try {
            var textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed";
            textArea.style.left = "-9999px";
            textArea.style.top = "0";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            var successful = document.execCommand('copy');
            document.body.removeChild(textArea);
            if (successful) handleSuccess();
            else handleError('execCommand returned false');
        } catch (err) {
            handleError(err);
        }
    }
}
</script>
