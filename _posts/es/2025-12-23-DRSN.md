---
layout: post
title: "Deep Residual Shrinkage Network: Un enfoque de inteligencia artificial para datos altamente ruidosos"
date: 2025-12-23
author: "Minghang Zhao, Harbin Institute of Technology"
tags: 
  - Deep Learning
  - Aprendizaje profundo
  - DRSN
  - Diagnóstico de fallos
  - Procesamiento de señales
  - ResNet
  - Mecanismos de atención
  - Umbralización suave
  - Reducción de ruido
mathjax: true
description: "Las Deep Residual Shrinkage Networks (DRSN) son un método de aprendizaje profundo diseñado para datos altamente ruidosos. Al integrar ResNet, mecanismos de atención y umbralización suave, DRSN destaca en el diagnóstico de fallos, el procesamiento de señales y la clasificación de imágenes, logrando una efectiva reducción de ruido."
lang: es
categories: es
ref: drsn-2025
buttons:
  - type: hit
    text: HIT Homepage
    url: https://homepage.hit.edu.cn/zhaominghang?lang=zh
  - type: scholar
    text: Google Scholar
    url: https://scholar.google.com/citations?user=k82TzLwAAAAJ&hl=en
  - type: ieee
    text: IEEE Paper
    url: https://ieeexplore.ieee.org/document/8850096
  - type: github
    text: GitHub Code
    url: https://github.com/zhao62/Deep-Residual-Shrinkage-Networks
  - type: citation
    text: "Citations: 1400+"
    url: https://scholar.google.com/citations?user=k82TzLwAAAAJ&hl=en
---

**La *Deep Residual Shrinkage Network* (DRSN) es una variante mejorada de la clásica ResNet (*Deep Residual Network*). En esencia, integra la arquitectura residual, mecanismos de atención y funciones de umbralización suave (*soft thresholding*).**

**Su principio de funcionamiento se puede resumir así: utiliza mecanismos de atención para identificar características (*features*) irrelevantes y emplea *soft thresholding* para anularlas (llevarlas a cero); simultáneamente, identifica y preserva las características relevantes. Esto potencia la capacidad de la red neuronal para extraer información útil incluso en señales altamente ruidosas.**

## 1. Motivación de la investigación
**En primer lugar, es inevitable que las muestras de clasificación contengan ruido, ya sea gaussiano, rosa, laplaciano, etc.** En un sentido más amplio, las muestras suelen contener información ajena a la tarea actual, lo cual también se interpreta como ruido. Este ruido degrada el rendimiento del modelo. (Cabe notar que el *soft thresholding* es un paso clave en algoritmos tradicionales de *denoising* de señales).

Por ejemplo, en una conversación junto a una carretera, el audio se mezcla con el claxon de los coches y el ruido del tráfico. Si aplicamos reconocimiento de voz, el resultado se verá afectado. Desde la perspectiva del *Deep Learning*, las características correspondientes al tráfico deberían ser **suprimidas** internamente por la red para evitar interferencias.

**En segundo lugar, la cantidad de ruido varía entre muestras dentro del mismo *dataset*.** (Esto se alinea con el concepto de atención: igual que la posición de un objeto varía entre imágenes y la red debe "enfocar" su atención en lugares distintos).

Imaginemos que entrenamos un clasificador "perro vs. gato" con 5 imágenes de perros: la 1ª tiene un perro y un ratón, la 2ª un perro y un ganso, la 3ª un perro y una gallina, etc. Durante el entrenamiento, el clasificador sufrirá la interferencia de estos objetos irrelevantes (ratones, gansos...), reduciendo la precisión (*accuracy*). Si logramos identificar y anular las características de estos elementos ajenos, mejoraremos significativamente el rendimiento del clasificador.

## 2. Umbralización Suave (*Soft Thresholding*)
**El *soft thresholding* es fundamental en la reducción de ruido. Consiste en eliminar las características cuyo valor absoluto es menor que un umbral (τ) y "contraer" hacia cero aquellas cuyo valor absoluto es mayor.** La fórmula es:

$$
y = \begin{cases} 
x - \tau & x > \tau \\ 
0 & -\tau \le x \le \tau \\ 
x + \tau & x < -\tau 
\end{cases}
$$

La derivada de la salida respecto a la entrada es:

$$
\frac{\partial y}{\partial x} = \begin{cases} 
1 & x > \tau \\ 
0 & -\tau \le x \le \tau \\ 
1 & x < -\tau 
\end{cases}
$$

Como se observa, la derivada es 1 o 0. Esta propiedad es idéntica a la función de activación **ReLU**. Por tanto, el *soft thresholding* también ayuda a mitigar el riesgo de *vanishing gradient* (desvanecimiento del gradiente) y *exploding gradient* en redes profundas.

**Para configurar el umbral, se deben cumplir dos condiciones: 1) debe ser positivo; 2) no puede superar el valor máximo de la señal de entrada (o la salida sería cero).**

**Además, existe una tercera condición ideal: cada muestra debe tener su propio umbral independiente, adaptado a su nivel de ruido específico.**

Esto es crucial porque el ruido no es homogéneo. En un mismo *dataset*, la Muestra A puede ser limpia y la Muestra B muy ruidosa. Por ende, la Muestra A requiere un umbral bajo y la B uno alto. Aunque en *Deep Learning* los umbrales pierden su significado físico explícito, la lógica de adaptabilidad se mantiene.

## 3. Mecanismo de Atención
El concepto es intuitivo en Visión por Computador (*Computer Vision*). El sistema visual biológico escanea rápidamente para detectar un objeto y luego "focaliza" su atención en él para extraer detalles, ignorando el fondo.

**SENet** (*Squeeze-and-Excitation Network*) es un referente en este campo. SENet asume que la contribución de cada canal de características (*feature channel*) varía según la muestra. Utiliza una sub-red para aprender un conjunto de pesos (*weights*) que, al multiplicarse por los canales, ajustan su importancia relativa.

<p align="center">
  <img src="/assets/img/DRSN/2025-11-25-DRSN-es/SENET_es_1.png" alt="Squeeze-and-Excitation Network" width="90%">
</p>

En este enfoque, cada muestra genera sus propios pesos. En SENet, estos se obtienen mediante: "*Global Average Pooling* → Capa Densa (*Fully Connected*) → ReLU → Capa Densa → Sigmoide".

<p align="center">
  <img src="/assets/img/DRSN/2025-11-25-DRSN-es/SENET_es_2.png" alt="Squeeze-and-Excitation Network" width="60%">
</p>

## 4. Umbralización Suave con Atención Profunda
La **DRSN** se inspira en la estructura de SENet para implementar un *soft thresholding* adaptativo. A través de una sub-red (marcada en rojo en los diagramas originales), la red aprende automáticamente el umbral óptimo para cada canal.

<p align="center">
  <img src="/assets/img/DRSN/2025-11-25-DRSN-es/DRSN_es_1.png" alt="Deep Residual Shrinkage Network" width="75%">
</p>

El proceso es el siguiente: primero se calcula el valor absoluto de todas las características del *feature map* de entrada. Luego, mediante *Global Average Pooling*, se obtiene un valor promedio A. Paralelamente, el mapa pasa por una pequeña red densa que finaliza en una función Sigmoide, generando un coeficiente α (entre 0 y 1). El umbral final se calcula como α×A. **Esto garantiza un umbral positivo y de magnitud controlada.**

**Lo brillante de este método es que cada muestra genera un umbral distinto. Funciona como un mecanismo de atención especializado: detecta características irrelevantes, las lleva cerca de 0 mediante capas convolucionales y las anula con el *soft thresholding*; a su vez, preserva las características relevantes.**

Finalmente, la red completa se construye apilando estos módulos básicos junto con capas convolucionales, *Batch Normalization*, activaciones, *Global Average Pooling* y la capa de salida.

<p align="center">
  <img src="/assets/img/DRSN/2025-11-25-DRSN-es/DRSN_es_2.png" alt="Deep Residual Shrinkage Network" width="55%">
</p>

## 5. Capacidad de Generalización
La **DRSN** es, de hecho, un método de aprendizaje de características (*feature learning*) de propósito general, aplicable siempre que las muestras contengan ruido o información irrelevante.

*   **En clasificación de imágenes:** Si el fondo contiene objetos distractores ("ruido"), la red puede usar la atención para detectarlos y anular sus características mediante *soft thresholding*, mejorando la precisión.
*   **En reconocimiento de voz:** En entornos ruidosos (fábricas, tráfico), la red ofrece una metodología robusta para limpiar la señal y mejorar la tasa de reconocimiento.

## 6. Impacto Académico

El artículo original cuenta con más de **1400 citas** en Google Scholar.

Se estima que la *Deep Residual Shrinkage Network* ha sido aplicada o mejorada en más de **1000 publicaciones** en campos tan diversos como ingeniería mecánica, sistemas eléctricos, visión por computador, medicina, procesamiento de voz y texto, radar y teledetección.

## 7. Información del artículo

<div style="background-color: #fff; border: 1px solid #e1e4e8; border-radius: 6px; padding: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); margin-bottom: 20px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;">
    
    <!-- 1. 论文标题 -->
    <div style="font-size: 18px; font-weight: 700; color: #0366d6; margin-bottom: 8px; line-height: 1.4;">
        <a href="https://ieeexplore.ieee.org/document/8850096" target="_blank" style="text-decoration: none; color: inherit; transition: color 0.2s;">
            Deep Residual Shrinkage Networks for Fault Diagnosis
        </a>
    </div>

    <!-- 2. 作者列表 -->
    <div style="font-size: 14px; color: #24292e; margin-bottom: 6px; line-height: 1.5;">
        <strong>Minghang Zhao</strong>, Shisheng Zhong, Xuyun Fu, Baoping Tang, Michael Pecht
    </div>

    <!-- 3. 期刊信息 -->
    <div style="font-size: 14px; color: #586069; font-style: italic; margin-bottom: 15px; line-height: 1.5;">
        IEEE Transactions on Industrial Informatics, vol. 16, no. 7, pp. 4681-4690, July 2020.
    </div>

    <!-- 4. 操作按钮行 (Mobile & Desktop Perfect) -->
    <div style="display: flex; gap: 8px; flex-wrap: wrap; align-items: center;">
        
        <!-- IEEE 官方链接 -->
        <a href="https://ieeexplore.ieee.org/document/8850096" target="_blank" style="text-decoration: none;">
            <div style="background: #00629B; color: white; padding: 5px 12px; border-radius: 4px; font-size: 12px; font-weight: 600; text-align: center; cursor: pointer; white-space: nowrap; line-height: normal; font-family: inherit;">
                IEEE Xplore
            </div>
        </a>

        <!-- PDF 下载 -->
        <a href="https://zhao62.github.io/assets/pdf/Zhao2020DRSN.pdf" target="_blank" style="text-decoration: none;">
            <div style="background: #cb2431; color: white; padding: 5px 12px; border-radius: 4px; font-size: 12px; font-weight: 600; text-align: center; cursor: pointer; white-space: nowrap; line-height: normal; font-family: inherit;">
                Download PDF
            </div>
        </a>

        <!-- 谷歌学术 -->
        <a href="https://scholar.google.com/citations?user=k82TzLwAAAAJ&hl=en" target="_blank" style="text-decoration: none;">
            <div style="background: #fff; color: #24292e; border: 1px solid #d1d5da; padding: 4px 11px; border-radius: 4px; font-size: 12px; font-weight: 600; text-align: center; cursor: pointer; white-space: nowrap; line-height: normal; font-family: inherit;">
                Google Scholar
            </div>
        </a>

        <!-- 复制纯文本按钮 -->
        <button id="btn-copy-cite-text-zhao2020" onclick="copyCitationText('citation-content-zhao2020', 'btn-copy-cite-text-zhao2020')" style="background: #f6f8fa; color: #24292e; border: 1px solid #d1d5da; padding: 4px 11px; border-radius: 4px; font-size: 12px; font-weight: 600; cursor: pointer; outline: none; font-family: inherit; line-height: normal;">
            Copy Citation
        </button>
    </div>

    <!-- 隐藏的纯文本源 -->
    <div id="citation-content-zhao2020" style="display: none;">M. Zhao, S. Zhong, X. Fu, B. Tang, and M. Pecht, "Deep Residual Shrinkage Networks for Fault Diagnosis," IEEE Transactions on Industrial Informatics, vol. 16, no. 7, pp. 4681-4690, 2020.</div>
</div>

<script>
function copyCitationText(contentId, btnId) {
    var content = document.getElementById(contentId).innerText;
    var btn = document.getElementById(btnId);

    function handleSuccess() {
        var originalText = btn.innerText;
        // 使用 textContent 兼容性更好
        btn.textContent = 'Copied! ✓';
        btn.style.color = '#22863a';
        btn.style.borderColor = '#22863a';
        setTimeout(function() {
            btn.textContent = 'Copy Citation';
            btn.style.color = '#24292e';
            btn.style.borderColor = '#d1d5da';
        }, 2000);
    }

    function handleError(err) {
        console.error('Copy failed', err);
        // 如果失败，不做任何操作，或者可以 alert
    }

    // 优先使用现代 Clipboard API
    if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(content).then(handleSuccess).catch(function() {
            fallbackCopyText(content);
        });
    } else {
        fallbackCopyText(content);
    }

    // 终极兼容：使用 execCommand
    function fallbackCopyText(text) {
        try {
            var textArea = document.createElement("textarea");
            textArea.value = text;
            
            // 关键优化：防止手机端弹出键盘
            textArea.setAttribute('readonly', '');
            textArea.style.position = "fixed";
            textArea.style.left = "-9999px";
            textArea.style.top = "0";
            
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            // 针对 iOS 的特殊处理
            var range = document.createRange();
            range.selectNodeContents(textArea);
            var selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            textArea.setSelectionRange(0, 999999);

            var successful = document.execCommand('copy');
            document.body.removeChild(textArea);
            
            if (successful) handleSuccess();
            else handleError('execCommand fail');
        } catch (err) {
            handleError(err);
        }
    }
}
</script>

## 8. BibTeX

<!-- 终极兼容版 BibTeX 块 -->
<div class="bibtex-container" style="border: 1px solid #e1e4e8; border-radius: 6px; background-color: #f6f8fa; margin-bottom: 16px; max-width: 100%;">
    
    <!-- 顶部工具栏 -->
    <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; border-bottom: 1px solid #e1e4e8; background-color: #ffffff; border-radius: 6px 6px 0 0;">
        <span style="font-size: 13px; font-weight: 600; color: #586069; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;">
            BibTeX
        </span>
        <button id="copy-btn-zhao2020" onclick="copyBibtexStable('bibtex-content-zhao2020', 'copy-btn-zhao2020')" style="border: 1px solid #d1d5da; background-color: #fff; color: #24292e; border-radius: 4px; padding: 4px 10px; font-size: 12px; cursor: pointer; font-weight: 600; line-height: 20px; transition: all 0.2s ease; outline: none;">
            Copy
        </button>
    </div>

    <!-- 代码区域 -->
    <div style="overflow-x: auto; padding: 15px;">
<!-- 注意：这里的第一行已经改成了 @article{Zhao2020DRSN, -->
<pre id="bibtex-content-zhao2020" style="margin: 0; font-family: SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace; font-size: 13px; line-height: 1.45; color: #24292e; white-space: pre;">@article{Zhao2020DRSN,
  author    = {Minghang Zhao and Shisheng Zhong and Xuyun Fu and Baoping Tang and Michael Pecht},
  title     = {Deep Residual Shrinkage Networks for Fault Diagnosis},
  journal   = {IEEE Transactions on Industrial Informatics},
  year      = {2020},
  volume    = {16},
  number    = {7},
  pages     = {4681-4690},
  doi       = {10.1109/TII.2019.2943898}
}</pre>
    </div>
</div>

<script>
/**
 * 高兼容性复制函数
 */
function copyBibtexStable(contentId, btnId) {
    var content = document.getElementById(contentId).innerText;
    var btn = document.getElementById(btnId);

    function handleSuccess() {
        btn.innerText = 'Copied! ✓';
        btn.style.color = '#22863a';
        btn.style.borderColor = '#22863a';
        setTimeout(function() {
            btn.innerText = 'Copy';
            btn.style.color = '#24292e';
            btn.style.borderColor = '#d1d5da';
        }, 2000);
    }

    function handleError(err) {
        console.error('Copy failed:', err);
        alert('Press Ctrl+C to copy');
    }

    if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(content).then(handleSuccess).catch(function() {
            fallbackCopy(content);
        });
    } else {
        fallbackCopy(content);
    }

    function fallbackCopy(text) {
        try {
            var textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed";
            textArea.style.left = "-9999px";
            textArea.style.top = "0";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            var successful = document.execCommand('copy');
            document.body.removeChild(textArea);
            if (successful) handleSuccess();
            else handleError('execCommand returned false');
        } catch (err) {
            handleError(err);
        }
    }
}
</script>
